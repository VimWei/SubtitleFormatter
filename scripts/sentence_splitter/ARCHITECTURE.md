# SmartSentenceSplitter 架构说明

## 整体处理逻辑

### 命令行入口（`main`）
- 解析参数：必填 `input_file`，可选 `--output`
- 递归控制参数：
  - `--min-length`（默认 70）：最小递归长度阈值；低于该长度不再继续递归拆分
  - `--max-depth`（默认 8）：最大递归深度；达到该深度即停止递归
- 校验路径，创建 `SmartSentenceSplitter`，调用 `process_file`

### 文件处理（`process_file`）
- 读取输入文件的非空行（每行即一个句子）
- 调用 `process_sentences` 进行拆分
- 将结果写入输出文件（未指定则自动生成 `data/output/<stem>.split.txt`）
- 输出统计信息

### 批量拆分（`process_sentences`）
- 遍历每个输入句子：
  - 调用 `split_sentence`，得到一到多行
- 拼接所有拆分结果返回

### 句子拆分（`split_sentence`）
- **核心流程**：
  - **步骤1**：通过 `find_split_points` 找到所有可能的候选拆分点
  - **步骤2**：通过 `_is_valid_split_point` 确认哪些候选点是有效的拆分点
  - **步骤3**：通过 `find_best_split` 从有效拆分点中找出最佳拆分点
- **非破坏式拆分**：
  - 若在逗号处分行，保证逗号及其后的一个空格留在上一行
  - 若在冒号处分行，保证冒号及其后的一个空格留在上一行
  - 直接用切片生成 `part1 = sentence[:split_pos]`、`part2 = sentence[split_pos:]`，不改动任何标点或空白
- **递归处理**：
  - **停止条件**：`depth >= max_depth` 或 `len(sentence) < min_recursive_length`
  - **递归逻辑**：对 `part1` 与 `part2` 各自独立评估；当某一部分 `len(part) >= min_recursive_length`（默认70）时，继续递归调用同一规则，否则直接收集该部分

### 多轮弱化策略（`find_split_points` + `_is_valid_split_point`）
- **候选来源**：
  - **标点**：`;`（最高）、`:`、`,`
  - **"逗号+连接词/模式"**（如 `, then`、`, so`、`, which` 等）提升优先级
  - **句中连接词**（and/or/but/because/while/which/that/...）
- **排除规则**：
  - **数字上下文**：精确识别数字/金额中的逗号（如 1,000、$3,000、€1,000,000），避免在此拆分
  - **简单并列**：基于词汇数量的简单判断，避免误拆句子结构
  - **从句内部**：避免在由 which/that/who/when/where 等引导的从句内部落点拆分
  - **代词保护**：特殊处理 `that` 代词，避免在 `do that,` 等结构中误拆
  - **长度要求**：需保证连接词前后有足够内容（句首只要求右侧足够）
- **5轮弱化**：
  - **第1轮**：完整检测（从句检测+简单并列检测+20字符长度要求）
  - **第2轮**：移除从句检测
  - **第3轮**：移除简单并列检测
  - **第4轮**：降低长度要求（10字符）
  - **第5轮**：移除所有限制
- 返回按位置升序排列的候选点列表

### 选择最佳拆分点（`find_best_split`）
- **优先级排序**：分号(5) > 冒号(4) > 逗号+连接词(3+boost) > 逗号(3) > 高优先级连接词(2) > 中优先级连接词(1) > 低优先级连接词(0)
- **位置偏好**：相同优先级时选择更靠左的拆分点
- **拆分条件**：5轮弱化后，若 `should_split_sentence` 仍为 False，则不拆